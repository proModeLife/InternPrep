{"id":958796182,"lang":"python3","lang_name":"Python3","time":"1 week, 4 days","timestamp":1685253274,"status":10,"status_display":"Accepted","runtime":"373 ms","url":"/submissions/detail/958796182/","is_pending":"Not Pending","title":"Shortest Bridge","memory":"19.6 MB","code":"from typing import List\nfrom collections import deque\n\nclass Solution:\n    def shortestBridge(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        paths = deque()\n        visited = set()  # Track visited cells to avoid revisiting\n\n        def dfs(i, j):\n            if i < 0 or j < 0 or i == n or j == m or grid[i][j] == 2:\n                return\n            elif grid[i][j] == 0:\n                grid[i][j] = 2\n                paths.append((i, j))\n                return\n            grid[i][j] = 2\n            dfs(i + 1, j)\n            dfs(i, j + 1)\n            dfs(i - 1, j)\n            dfs(i, j - 1)\n\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    dfs(i, j)\n                    break\n            if paths:  # If the first island is found, break out of the loop\n                break\n\n        flips = 1\n        while paths:\n            for _ in range(len(paths)):  # Process all cells in the current level\n                i, j = paths.popleft()\n                if (i, j) in visited:\n                    continue\n                visited.add((i, j))\n                if i > 0 and grid[i - 1][j] == 1 or \\\n                   j > 0 and grid[i][j - 1] == 1 or \\\n                   i < n - 1 and grid[i + 1][j] == 1 or \\\n                   j < m - 1 and grid[i][j + 1] == 1:\n                    return flips\n                if i > 0 and grid[i - 1][j] == 0:\n                    paths.append((i - 1, j))\n                if j > 0 and grid[i][j - 1] == 0:\n                    paths.append((i, j - 1))\n                if i < n - 1 and grid[i + 1][j] == 0:\n                    paths.append((i + 1, j))\n                if j < m - 1 and grid[i][j + 1] == 0:\n                    paths.append((i, j + 1))\n            flips += 1\n\n        return -1  # If the second island is not found\n\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-bridge","has_notes":false}