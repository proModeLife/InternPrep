{"id":965353545,"lang":"python3","lang_name":"Python3","time":"1 day, 13 hours","timestamp":1686074774,"status":10,"status_display":"Accepted","runtime":"658 ms","url":"/submissions/detail/965353545/","is_pending":"Not Pending","title":"Shortest Path in Binary Matrix","memory":"16.6 MB","code":"from typing import List\n\nclass Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        # Check if the starting or ending cell is blocked\n        if grid[0][0] == 1 or grid[-1][-1] == 1:\n            return -1\n        \n        # Define the 8 possible directions of movement\n        directions = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n        \n        # Initialize the queue with the starting position and its cost\n        queue = [(0, 0, 1)]\n        \n        # Mark the starting cell as visited\n        grid[0][0] = 1\n        \n        # Perform BFS\n        while queue:\n            # Pop the first cell from the queue\n            i, j, cost = queue.pop(0)\n            \n            # Check if we have reached the ending cell\n            if i == len(grid) - 1 and j == len(grid[0]) - 1:\n                return cost\n            \n            # Explore the neighbors of the current cell\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                \n                # Check if the neighbor is within bounds and unvisited\n                if 0 <= ni < len(grid) and 0 <= nj < len(grid[0]) and grid[ni][nj] == 0:\n                    # Mark the neighbor as visited and add it to the queue\n                    grid[ni][nj] = 1\n                    queue.append((ni, nj, cost + 1))\n        \n        # If we have not found the ending cell, return -1\n        return -1","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-binary-matrix","has_notes":false}