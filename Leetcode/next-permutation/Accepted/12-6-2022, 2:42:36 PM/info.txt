{"id":855486291,"lang":"cpp","lang_name":"C++","time":"6Â months","timestamp":1670317956,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/855486291/","is_pending":"Not Pending","title":"Next Permutation","memory":"12.1 MB","code":"class Solution {\npublic:\n    void nextPermutation(vector<int>& nums)\n{\n    int len = nums.size();\n\n    // Find the first element from the right that is smaller than the element\n    // immediately after it\n    int idx = len - 2;\n    while (idx >= 0 && nums[idx] >= nums[idx + 1])\n    {\n        idx--;\n    }\n\n    // If no such element is found, the array is already in non-ascending order\n    // and the next permutation is the array sorted in ascending order\n    if (idx < 0)\n    {\n        sort(nums.begin(), nums.end());\n        return;\n    }\n\n    // Find the smallest element in the suffix that is greater than nums[idx]\n    int jdx = len - 1;\n    while (nums[jdx] <= nums[idx])\n    {\n        jdx--;\n    }\n\n    // Swap the elements at indices idx and jdx\n    swap(nums[idx], nums[jdx]);\n\n    // Reverse the suffix\n    reverse(nums.begin() + idx + 1, nums.end());\n}\n\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"next-permutation","has_notes":false}